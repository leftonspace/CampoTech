<?xml version="1.0" encoding="UTF-8"?>
<!--
  CampoTech Security & Compliance Implementation
  AI Agent Execution Prompt
  Based on: CAMPOTECH-SECURITY-COMPLIANCE-GUIDE.md
  Created: 2025-12-13
-->

<security_implementation_task>
  
  <metadata>
    <project>CampoTech FSM Platform</project>
    <module>Security &amp; Compliance</module>
    <version>1.0</version>
    <priority>P0 - Critical</priority>
    <estimated_duration>6-8 weeks full implementation</estimated_duration>
    <stack>Next.js 14, Prisma, Supabase, TypeScript, Zod</stack>
    <target_scale>100,000+ businesses in Buenos Aires</target_scale>
  </metadata>

  <legal_framework>
    <law name="Ley 25.326" purpose="Personal Data Protection" status="Active"/>
    <law name="Decreto 1558/2001" purpose="Regulatory decree for Ley 25.326" status="Active"/>
    <law name="Resolución AAIP 126/2024" purpose="Updated sanctions regime" status="Active since June 2024"/>
    <law name="Ley 26.388" purpose="Computer Crimes" status="Active"/>
    <law name="Ley 25.506" purpose="Digital Signature" status="Active"/>
    <law name="Decreto 953/2024" purpose="AFIP to ARCA Transition" status="Active October 2024"/>
    <law name="RG 5614/2024" purpose="Fiscal Transparency Regime" status="Active January 2025"/>
    
    <sanctions_reference>
      <severity level="LEVE" fine_range="ARS 1,000 - 25,000" other="Up to 2 warnings"/>
      <severity level="GRAVE" fine_range="ARS 25,001 - 80,000" other="Up to 4 warnings, 1-30 day suspension"/>
      <severity level="MUY_GRAVE" fine_range="ARS 80,001 - 100,000" other="Database closure, suspension"/>
      <maximum_exposure>ARS 50,000,000 per proceeding (500x multiplier)</maximum_exposure>
    </sanctions_reference>
  </legal_framework>

  <risk_factors>
    <risk>Personal data of technicians, customers, and business owners</risk>
    <risk>AFIP/ARCA integration with fiscal credentials</risk>
    <risk>Payment processing via Mercado Pago</risk>
    <risk>Real-time location tracking</risk>
    <risk>WhatsApp communication with message history</risk>
    <risk>Multi-tenant SaaS architecture</risk>
  </risk_factors>

  <!-- ============================================ -->
  <!-- PHASE 0: RECONNAISSANCE                      -->
  <!-- ============================================ -->
  
  <phase id="0" name="reconnaissance" priority="CRITICAL" timeout="30min">
    <description>
      Analyze existing codebase to understand current security posture and identify gaps.
    </description>
    
    <step id="0.1" name="find_auth_middleware">
      <action>Locate existing authentication middleware</action>
      <commands>
        <command>find . -name "*auth*" -type f -name "*.ts" | grep -v node_modules | head -20</command>
        <command>grep -r "getServerSession\|requireAuth\|withAuth" --include="*.ts" | head -20</command>
      </commands>
      <store_as>AUTH_MIDDLEWARE_PATH</store_as>
    </step>
    
    <step id="0.2" name="audit_prisma_queries">
      <action>Find all Prisma queries that may lack organization isolation</action>
      <commands>
        <command>grep -rn "prisma\.\w*\.findMany\|findFirst\|findUnique\|create\|update\|delete" --include="*.ts" | grep -v "organizationId" | grep -v node_modules</command>
      </commands>
      <store_as>UNPROTECTED_QUERIES</store_as>
      <severity_if_found>CRITICAL</severity_if_found>
    </step>
    
    <step id="0.3" name="find_api_routes">
      <action>List all API routes that need protection</action>
      <commands>
        <command>find . -path "*/api/*" -name "route.ts" | grep -v node_modules</command>
      </commands>
      <store_as>API_ROUTES</store_as>
    </step>
    
    <step id="0.4" name="check_webhooks">
      <action>Find webhook endpoints</action>
      <commands>
        <command>find . -path "*webhook*" -name "*.ts" | grep -v node_modules</command>
        <command>grep -r "x-hub-signature\|x-signature" --include="*.ts" | head -10</command>
      </commands>
      <store_as>WEBHOOK_ENDPOINTS</store_as>
    </step>
    
    <step id="0.5" name="check_env_secrets">
      <action>Verify sensitive data is not hardcoded</action>
      <commands>
        <command>grep -rn "password\|secret\|api_key\|token" --include="*.ts" --include="*.tsx" | grep -v "process.env" | grep -v node_modules | grep -v ".d.ts"</command>
      </commands>
      <store_as>HARDCODED_SECRETS</store_as>
      <severity_if_found>CRITICAL</severity_if_found>
    </step>
    
    <step id="0.6" name="check_existing_validation">
      <action>Find existing Zod validation schemas</action>
      <commands>
        <command>grep -rn "z\.object\|z\.string\|z\.number" --include="*.ts" | head -30</command>
        <command>find . -name "*schema*" -o -name "*validation*" | grep -v node_modules</command>
      </commands>
      <store_as>EXISTING_VALIDATION</store_as>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 1: AUTHENTICATION SECURITY (Week 1)    -->
  <!-- ============================================ -->
  
  <phase id="1" name="authentication_security" priority="CRITICAL" timeline="Week 1">
    <description>
      Implement secure authentication with OTP, session management, and rate limiting.
    </description>
    
    <step id="1.1" name="create_require_auth_middleware">
      <action>Create or update authentication middleware</action>
      <file>lib/middleware/require-auth.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { getServerSession } from 'next-auth';
import { NextResponse } from 'next/server';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export type Role = 'OWNER' | 'ADMIN' | 'DISPATCHER' | 'TECHNICIAN' | 'ACCOUNTANT';

export interface AuthSession {
  userId: string;
  organizationId: string;
  role: Role;
  email: string;
}

export async function requireAuth(
  request: Request,
  requiredRoles?: Role[]
): Promise<AuthSession | NextResponse> {
  try {
    const session = await getServerSession(authOptions);
    
    // Check authentication
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: 'No autorizado' },
        { status: 401 }
      );
    }
    
    // Get user with organization
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { organization: true }
    });
    
    if (!user || !user.organization) {
      return NextResponse.json(
        { success: false, error: 'Usuario no encontrado' },
        { status: 401 }
      );
    }
    
    // Check if user is active
    if (user.status !== 'ACTIVE') {
      return NextResponse.json(
        { success: false, error: 'Cuenta suspendida' },
        { status: 403 }
      );
    }
    
    // Check organization status
    if (user.organization.status === 'SUSPENDED') {
      return NextResponse.json(
        { success: false, error: 'Organización suspendida' },
        { status: 403 }
      );
    }
    
    // Check role authorization
    if (requiredRoles && requiredRoles.length > 0) {
      if (!requiredRoles.includes(user.role as Role)) {
        return NextResponse.json(
          { success: false, error: 'Acceso denegado' },
          { status: 403 }
        );
      }
    }
    
    return {
      userId: user.id,
      organizationId: user.organizationId,
      role: user.role as Role,
      email: user.email
    };
  } catch (error) {
    console.error('[Auth] Error:', error);
    return NextResponse.json(
      { success: false, error: 'Error de autenticación' },
      { status: 500 }
    );
  }
}
]]></content>
    </step>
    
    <step id="1.2" name="create_rate_limiter">
      <action>Implement rate limiting</action>
      <file>lib/rate-limit.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';
import { NextResponse } from 'next/server';

// Initialize Redis (fallback to memory if no Redis configured)
let redis: Redis | null = null;

try {
  if (process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN) {
    redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN
    });
  }
} catch (error) {
  console.warn('[RateLimit] Redis not configured, using memory fallback');
}

// Rate limiters for different endpoints
export const rateLimiters = {
  // Authentication: 5 requests per 15 minutes
  auth: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(5, '15 m'),
    analytics: true,
    prefix: 'ratelimit:auth'
  }) : null,
  
  // OTP requests: 3 per 5 minutes
  otp: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(3, '5 m'),
    analytics: true,
    prefix: 'ratelimit:otp'
  }) : null,
  
  // General API: 100 per minute
  api: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(100, '1 m'),
    analytics: true,
    prefix: 'ratelimit:api'
  }) : null,
  
  // Invoicing (ARCA): 30 per minute
  invoicing: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(30, '1 m'),
    analytics: true,
    prefix: 'ratelimit:invoice'
  }) : null,
  
  // Webhooks: 100 per minute
  webhooks: redis ? new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(100, '1 m'),
    analytics: true,
    prefix: 'ratelimit:webhook'
  }) : null
};

export async function checkRateLimit(
  limiterType: keyof typeof rateLimiters,
  identifier: string
): Promise<{ success: boolean; remaining?: number; reset?: number }> {
  const limiter = rateLimiters[limiterType];
  
  if (!limiter) {
    // No Redis configured, allow request but log warning
    console.warn(`[RateLimit] No limiter for ${limiterType}, allowing request`);
    return { success: true };
  }
  
  const result = await limiter.limit(identifier);
  
  return {
    success: result.success,
    remaining: result.remaining,
    reset: result.reset
  };
}

export function rateLimitResponse(reset?: number): NextResponse {
  return NextResponse.json(
    { 
      success: false, 
      error: 'Demasiadas solicitudes. Intente nuevamente más tarde.',
      retryAfter: reset ? Math.ceil((reset - Date.now()) / 1000) : 60
    },
    { 
      status: 429,
      headers: {
        'Retry-After': String(reset ? Math.ceil((reset - Date.now()) / 1000) : 60)
      }
    }
  );
}
]]></content>
    </step>
    
    <step id="1.3" name="create_session_config">
      <action>Configure secure session settings</action>
      <file>lib/auth/session-config.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
// Session configuration per security requirements
export const SESSION_CONFIG = {
  // JWT settings
  accessTokenExpiry: '15m',
  refreshTokenExpiry: '7d',
  
  // Cookie security
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict' as const,
    path: '/',
    maxAge: 7 * 24 * 60 * 60 // 7 days in seconds
  },
  
  // Security policies
  rotateRefreshToken: true,
  revokeOnPasswordChange: true,
  singleSessionPerDevice: false, // Allow multiple devices
  
  // Monitoring
  logAllAuthentications: true,
  alertOnAnomalousLogin: true,
  
  // OTP settings
  otp: {
    length: 6,
    expiryMinutes: 5,
    maxAttempts: 5,
    lockoutMinutes: 30
  }
};

// Validate JWT secret is strong enough
export function validateJwtSecret(): boolean {
  const secret = process.env.JWT_SECRET || process.env.NEXTAUTH_SECRET;
  if (!secret || secret.length < 32) {
    console.error('[Security] JWT secret must be at least 32 characters');
    return false;
  }
  return true;
}
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 2: ORGANIZATION ISOLATION (Week 1)     -->
  <!-- ============================================ -->
  
  <phase id="2" name="organization_isolation" priority="CRITICAL" timeline="Week 1">
    <description>
      Ensure complete multi-tenant data isolation. This is the most critical security requirement.
    </description>
    
    <step id="2.1" name="create_org_isolation_middleware">
      <action>Create organization isolation helper</action>
      <file>lib/middleware/org-isolation.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { AuthSession } from './require-auth';

/**
 * CRITICAL: Add organization filter to any Prisma query
 * 
 * This middleware ensures multi-tenant data isolation.
 * NEVER query the database without filtering by organizationId.
 */
export function withOrgIsolation<T extends Record<string, any>>(
  where: T,
  session: AuthSession
): T & { organizationId: string } {
  return {
    ...where,
    organizationId: session.organizationId
  };
}

/**
 * Validate that an entity belongs to the user's organization
 */
export async function validateOwnership(
  entityOrgId: string | null | undefined,
  session: AuthSession
): Promise<boolean> {
  if (!entityOrgId) return false;
  return entityOrgId === session.organizationId;
}

/**
 * Get organizationId filter for Prisma queries
 * Use this in every findMany, findFirst, count, etc.
 */
export function orgFilter(session: AuthSession) {
  return { organizationId: session.organizationId };
}
]]></content>
    </step>
    
    <step id="2.2" name="audit_and_fix_queries">
      <action>Audit all Prisma queries and add organization filter</action>
      <instructions>
        For EVERY file found in reconnaissance step 0.2 (UNPROTECTED_QUERIES):
        1. Locate the Prisma query
        2. Add organizationId filter from session
        3. Ensure session is obtained via requireAuth
        
        Example transformation:
        
        BEFORE (DANGEROUS):
        const jobs = await prisma.job.findMany();
        
        AFTER (SAFE):
        const session = await requireAuth(request);
        if (session instanceof NextResponse) return session;
        
        const jobs = await prisma.job.findMany({
          where: { organizationId: session.organizationId }
        });
      </instructions>
      <verify>
        <command>grep -rn "prisma\.\w*\.findMany\|findFirst\|findUnique" --include="*.ts" | grep -v "organizationId" | grep -v node_modules | wc -l</command>
        <expected>0</expected>
      </verify>
    </step>
    
    <step id="2.3" name="create_rbac_matrix">
      <action>Implement role-based access control</action>
      <file>lib/auth/rbac.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { Role } from '../middleware/require-auth';

type Permission = 
  | 'jobs:read' | 'jobs:read:own' | 'jobs:create' | 'jobs:update' | 'jobs:delete' | 'jobs:assign'
  | 'customers:read' | 'customers:create' | 'customers:update' | 'customers:delete'
  | 'employees:read' | 'employees:create' | 'employees:update' | 'employees:delete'
  | 'invoices:read' | 'invoices:create' | 'invoices:cancel'
  | 'payments:read' | 'payments:process'
  | 'reports:read' | 'reports:financial'
  | 'settings:read' | 'settings:update'
  | 'org:delete'
  | 'afip:manage';

const ROLE_PERMISSIONS: Record<Role, Permission[]> = {
  OWNER: [
    'jobs:read', 'jobs:create', 'jobs:update', 'jobs:delete', 'jobs:assign',
    'customers:read', 'customers:create', 'customers:update', 'customers:delete',
    'employees:read', 'employees:create', 'employees:update', 'employees:delete',
    'invoices:read', 'invoices:create', 'invoices:cancel',
    'payments:read', 'payments:process',
    'reports:read', 'reports:financial',
    'settings:read', 'settings:update',
    'org:delete',
    'afip:manage'
  ],
  ADMIN: [
    'jobs:read', 'jobs:create', 'jobs:update', 'jobs:delete', 'jobs:assign',
    'customers:read', 'customers:create', 'customers:update', 'customers:delete',
    'employees:read', 'employees:create', 'employees:update', 'employees:delete',
    'invoices:read', 'invoices:create', 'invoices:cancel',
    'payments:read', 'payments:process',
    'reports:read', 'reports:financial',
    'settings:read', 'settings:update',
    'afip:manage'
  ],
  DISPATCHER: [
    'jobs:read', 'jobs:create', 'jobs:update', 'jobs:assign',
    'customers:read', 'customers:create', 'customers:update',
    'employees:read',
    'reports:read'
  ],
  TECHNICIAN: [
    'jobs:read:own', 'jobs:update',
    'customers:read'
  ],
  ACCOUNTANT: [
    'invoices:read', 'invoices:create', 'invoices:cancel',
    'payments:read',
    'reports:read', 'reports:financial',
    'afip:manage'
  ]
};

export function hasPermission(role: Role, permission: Permission): boolean {
  return ROLE_PERMISSIONS[role]?.includes(permission) ?? false;
}

export function requirePermission(role: Role, permission: Permission): void {
  if (!hasPermission(role, permission)) {
    throw new Error(`Role ${role} does not have permission ${permission}`);
  }
}

export function getPermissions(role: Role): Permission[] {
  return ROLE_PERMISSIONS[role] || [];
}
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 3: INPUT VALIDATION (Week 2)           -->
  <!-- ============================================ -->
  
  <phase id="3" name="input_validation" priority="CRITICAL" timeline="Week 2">
    <description>
      Implement comprehensive input validation using Zod schemas to prevent injection attacks.
    </description>
    
    <step id="3.1" name="create_validation_schemas">
      <action>Create Zod validation schemas for all entities</action>
      <file>lib/validation/schemas.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { z } from 'zod';

// ============================================
// ARGENTINE TAX ID VALIDATION
// ============================================

/**
 * Validate CUIT/CUIL checksum (Módulo 11)
 */
function validateCuitChecksum(cuit: string): boolean {
  const cleaned = cuit.replace(/-/g, '');
  if (cleaned.length !== 11) return false;
  
  const multipliers = [5, 4, 3, 2, 7, 6, 5, 4, 3, 2];
  let sum = 0;
  
  for (let i = 0; i < 10; i++) {
    sum += parseInt(cleaned[i]) * multipliers[i];
  }
  
  const remainder = sum % 11;
  const checkDigit = remainder === 0 ? 0 : remainder === 1 ? 9 : 11 - remainder;
  
  return checkDigit === parseInt(cleaned[10]);
}

// CUIT validation (XX-XXXXXXXX-X)
export const cuitSchema = z.string()
  .regex(/^\d{2}-\d{8}-\d{1}$/, 'Formato de CUIT inválido (XX-XXXXXXXX-X)')
  .refine(validateCuitChecksum, 'Dígito verificador de CUIT inválido');

// CUIL validation (same format as CUIT)
export const cuilSchema = z.string()
  .regex(/^\d{2}-\d{8}-\d{1}$/, 'Formato de CUIL inválido (XX-XXXXXXXX-X)')
  .refine(validateCuitChecksum, 'Dígito verificador de CUIL inválido');

// ============================================
// PHONE VALIDATION (ARGENTINA)
// ============================================

export const phoneSchema = z.string()
  .regex(/^\+54(9)?\d{10}$/, 'Número de teléfono argentino inválido (+54XXXXXXXXXX)');

// ============================================
// COMMON SCHEMAS
// ============================================

export const emailSchema = z.string()
  .email('Email inválido')
  .max(255);

export const passwordSchema = z.string()
  .min(8, 'La contraseña debe tener al menos 8 caracteres')
  .max(100)
  .regex(/[A-Z]/, 'Debe contener al menos una mayúscula')
  .regex(/[a-z]/, 'Debe contener al menos una minúscula')
  .regex(/[0-9]/, 'Debe contener al menos un número');

export const uuidSchema = z.string().uuid('ID inválido');
export const cuidSchema = z.string().cuid('ID inválido');

// ============================================
// ADDRESS SCHEMA
// ============================================

export const addressSchema = z.object({
  street: z.string().min(3).max(200),
  city: z.string().min(2).max(100),
  province: z.string().min(2).max(100),
  postalCode: z.string().regex(/^\d{4}$/, 'Código postal debe ser de 4 dígitos'),
  lat: z.number().min(-90).max(90).optional(),
  lng: z.number().min(-180).max(180).optional()
});

// ============================================
// JOB SCHEMAS
// ============================================

export const createJobSchema = z.object({
  customerId: z.string().cuid(),
  title: z.string().min(3).max(200),
  description: z.string().max(2000).optional(),
  scheduledDate: z.string().datetime(),
  estimatedDuration: z.number().int().min(15).max(480),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']),
  serviceTypeId: z.string().cuid().optional(),
  address: addressSchema,
  assignedTechnicianId: z.string().cuid().optional()
});

export const updateJobSchema = createJobSchema.partial();

// ============================================
// CUSTOMER SCHEMAS
// ============================================

export const createCustomerSchema = z.object({
  name: z.string().min(2).max(200),
  email: emailSchema.optional(),
  phone: phoneSchema,
  cuit: cuitSchema.optional(),
  address: addressSchema.optional(),
  notes: z.string().max(1000).optional()
});

export const updateCustomerSchema = createCustomerSchema.partial();

// ============================================
// EMPLOYEE SCHEMAS
// ============================================

export const createEmployeeSchema = z.object({
  name: z.string().min(2).max(200),
  email: emailSchema,
  phone: phoneSchema,
  cuil: cuilSchema,
  role: z.enum(['ADMIN', 'DISPATCHER', 'TECHNICIAN', 'ACCOUNTANT']),
  startDate: z.string().datetime().optional()
});

// ============================================
// INVOICE SCHEMAS (ARCA COMPLIANT)
// ============================================

export const invoiceItemSchema = z.object({
  description: z.string().min(1).max(500),
  quantity: z.number().positive(),
  unitPrice: z.number().positive(), // in centavos
  ivaRate: z.enum(['0', '10.5', '21', '27'])
});

export const createInvoiceSchema = z.object({
  customerId: z.string().cuid(),
  jobIds: z.array(z.string().cuid()).min(1).optional(),
  invoiceType: z.enum(['A', 'B', 'C', 'E']),
  paymentMethod: z.enum(['CASH', 'TRANSFER', 'CARD', 'MERCADOPAGO', 'CHECK']),
  items: z.array(invoiceItemSchema).min(1),
  notes: z.string().max(500).optional()
});

// ============================================
// SEARCH/FILTER SCHEMAS (SQL INJECTION PREVENTION)
// ============================================

export const searchQuerySchema = z.object({
  q: z.string().max(200).optional(),
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(50),
  sortBy: z.string().max(50).optional(),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
});

// ============================================
// VALIDATION HELPER
// ============================================

export function validateInput<T>(schema: z.ZodSchema<T>, data: unknown): {
  success: true;
  data: T;
} | {
  success: false;
  errors: { field: string; message: string }[];
} {
  const result = schema.safeParse(data);
  
  if (result.success) {
    return { success: true, data: result.data };
  }
  
  return {
    success: false,
    errors: result.error.errors.map(e => ({
      field: e.path.join('.'),
      message: e.message
    }))
  };
}
]]></content>
    </step>
    
    <step id="3.2" name="create_sanitization_utils">
      <action>Create input sanitization utilities</action>
      <file>lib/validation/sanitize.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import DOMPurify from 'isomorphic-dompurify';

/**
 * Sanitize HTML content to prevent XSS
 * Only allow basic formatting tags
 */
export function sanitizeHtml(dirty: string): string {
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: []
  });
}

/**
 * Strip all HTML tags
 */
export function stripHtml(input: string): string {
  return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
}

/**
 * Sanitize string for safe database storage
 * Removes null bytes and other dangerous characters
 */
export function sanitizeString(input: string): string {
  return input
    .replace(/\x00/g, '') // Null bytes
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // Control characters
    .trim();
}

/**
 * Normalize phone number to E.164 format
 */
export function normalizePhone(phone: string): string {
  // Remove all non-digits except +
  let cleaned = phone.replace(/[^\d+]/g, '');
  
  // Ensure starts with +54 for Argentina
  if (!cleaned.startsWith('+')) {
    if (cleaned.startsWith('54')) {
      cleaned = '+' + cleaned;
    } else if (cleaned.startsWith('0')) {
      cleaned = '+54' + cleaned.substring(1);
    } else {
      cleaned = '+54' + cleaned;
    }
  }
  
  return cleaned;
}

/**
 * Normalize CUIT/CUIL format
 */
export function normalizeCuit(cuit: string): string {
  const digits = cuit.replace(/\D/g, '');
  if (digits.length !== 11) return cuit;
  return `${digits.slice(0, 2)}-${digits.slice(2, 10)}-${digits.slice(10)}`;
}
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 4: WEBHOOK SECURITY (Week 1)           -->
  <!-- ============================================ -->
  
  <phase id="4" name="webhook_security" priority="CRITICAL" timeline="Week 1">
    <description>
      Secure all webhook endpoints with signature verification.
    </description>
    
    <step id="4.1" name="create_mercadopago_webhook">
      <action>Implement secure MercadoPago webhook</action>
      <file>app/api/webhooks/mercadopago/route.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';
import { prisma } from '@/lib/prisma';
import { checkRateLimit, rateLimitResponse } from '@/lib/rate-limit';

export async function POST(request: NextRequest) {
  try {
    // Rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown';
    const rateLimit = await checkRateLimit('webhooks', `mp:${ip}`);
    if (!rateLimit.success) {
      return rateLimitResponse(rateLimit.reset);
    }
    
    // Get headers and body
    const signature = request.headers.get('x-signature');
    const requestId = request.headers.get('x-request-id');
    const body = await request.text();
    
    if (!signature || !requestId) {
      console.error('[MP Webhook] Missing signature or request ID');
      return NextResponse.json({ error: 'Missing headers' }, { status: 401 });
    }
    
    // Parse signature components
    const signatureParts = signature.split(',');
    const ts = signatureParts.find(p => p.startsWith('ts='))?.split('=')[1];
    const v1 = signatureParts.find(p => p.startsWith('v1='))?.split('=')[1];
    
    if (!ts || !v1) {
      console.error('[MP Webhook] Invalid signature format');
      return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
    }
    
    // Verify signature
    const secret = process.env.MP_WEBHOOK_SECRET;
    if (!secret) {
      console.error('[MP Webhook] MP_WEBHOOK_SECRET not configured');
      return NextResponse.json({ error: 'Server error' }, { status: 500 });
    }
    
    // Build manifest for signature verification
    const data = JSON.parse(body);
    const dataId = data.data?.id || '';
    const manifest = `id:${dataId};request-id:${requestId};ts:${ts};`;
    
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(manifest)
      .digest('hex');
    
    if (!crypto.timingSafeEqual(Buffer.from(v1), Buffer.from(expectedSignature))) {
      console.error('[MP Webhook] Signature mismatch');
      return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
    }
    
    // Log webhook for debugging/audit
    await prisma.webhookLog.create({
      data: {
        source: 'MERCADOPAGO',
        eventType: data.type || 'unknown',
        payload: data,
        requestId,
        processed: false
      }
    });
    
    // Process the webhook asynchronously
    // Don't block the response - MercadoPago expects quick 200
    processPaymentNotification(data).catch(err => {
      console.error('[MP Webhook] Processing error:', err);
    });
    
    return NextResponse.json({ received: true }, { status: 200 });
    
  } catch (error) {
    console.error('[MP Webhook] Error:', error);
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}

async function processPaymentNotification(data: any) {
  // Implement payment processing logic
  // Update payment status, invoice status, etc.
}
]]></content>
    </step>
    
    <step id="4.2" name="create_whatsapp_webhook">
      <action>Implement secure WhatsApp webhook</action>
      <file>app/api/webhooks/whatsapp/route.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';
import { prisma } from '@/lib/prisma';
import { checkRateLimit, rateLimitResponse } from '@/lib/rate-limit';

// GET: Webhook verification (required by Meta)
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  
  const mode = searchParams.get('hub.mode');
  const token = searchParams.get('hub.verify_token');
  const challenge = searchParams.get('hub.challenge');
  
  const verifyToken = process.env.WHATSAPP_WEBHOOK_VERIFY_TOKEN;
  
  if (mode === 'subscribe' && token === verifyToken) {
    console.log('[WA Webhook] Verification successful');
    return new NextResponse(challenge, { status: 200 });
  }
  
  console.error('[WA Webhook] Verification failed');
  return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
}

// POST: Receive messages
export async function POST(request: NextRequest) {
  try {
    // Rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown';
    const rateLimit = await checkRateLimit('webhooks', `wa:${ip}`);
    if (!rateLimit.success) {
      return rateLimitResponse(rateLimit.reset);
    }
    
    // Get signature and body
    const signature = request.headers.get('x-hub-signature-256');
    const body = await request.text();
    
    if (!signature) {
      console.error('[WA Webhook] Missing signature');
      return NextResponse.json({ error: 'Missing signature' }, { status: 401 });
    }
    
    // Verify signature
    const secret = process.env.WHATSAPP_APP_SECRET;
    if (!secret) {
      console.error('[WA Webhook] WHATSAPP_APP_SECRET not configured');
      return NextResponse.json({ error: 'Server error' }, { status: 500 });
    }
    
    const expectedSignature = 'sha256=' + crypto
      .createHmac('sha256', secret)
      .update(body)
      .digest('hex');
    
    if (!crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    )) {
      console.error('[WA Webhook] Signature mismatch');
      return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
    }
    
    const data = JSON.parse(body);
    
    // Log webhook
    await prisma.webhookLog.create({
      data: {
        source: 'WHATSAPP',
        eventType: 'message',
        payload: data,
        processed: false
      }
    });
    
    // Process asynchronously
    processWhatsAppMessage(data).catch(err => {
      console.error('[WA Webhook] Processing error:', err);
    });
    
    return NextResponse.json({ received: true }, { status: 200 });
    
  } catch (error) {
    console.error('[WA Webhook] Error:', error);
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}

async function processWhatsAppMessage(data: any) {
  // Implement message processing logic
}
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 5: DATA ENCRYPTION (Week 2)            -->
  <!-- ============================================ -->
  
  <phase id="5" name="data_encryption" priority="HIGH" timeline="Week 2">
    <description>
      Implement field-level encryption for sensitive data.
    </description>
    
    <step id="5.1" name="create_encryption_utils">
      <action>Create AES-256-GCM encryption utilities</action>
      <file>lib/encryption/crypto.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { createCipheriv, createDecipheriv, randomBytes, scrypt } from 'crypto';
import { promisify } from 'util';

const scryptAsync = promisify(scrypt);
const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const AUTH_TAG_LENGTH = 16;
const SALT_LENGTH = 32;

// Get encryption key from environment
function getEncryptionKey(): Buffer {
  const key = process.env.ENCRYPTION_KEY;
  if (!key) {
    throw new Error('ENCRYPTION_KEY environment variable not set');
  }
  if (key.length !== 64) { // 32 bytes = 64 hex chars
    throw new Error('ENCRYPTION_KEY must be 64 hex characters (32 bytes)');
  }
  return Buffer.from(key, 'hex');
}

/**
 * Encrypt sensitive data using AES-256-GCM
 * Returns: iv:authTag:ciphertext (all hex encoded)
 */
export function encrypt(plaintext: string): string {
  const key = getEncryptionKey();
  const iv = randomBytes(IV_LENGTH);
  
  const cipher = createCipheriv(ALGORITHM, key, iv);
  
  let encrypted = cipher.update(plaintext, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
}

/**
 * Decrypt data encrypted with encrypt()
 */
export function decrypt(ciphertext: string): string {
  const key = getEncryptionKey();
  const [ivHex, authTagHex, encrypted] = ciphertext.split(':');
  
  if (!ivHex || !authTagHex || !encrypted) {
    throw new Error('Invalid ciphertext format');
  }
  
  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  
  const decipher = createDecipheriv(ALGORITHM, key, iv);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

/**
 * Check if a string is encrypted (basic format check)
 */
export function isEncrypted(value: string): boolean {
  const parts = value.split(':');
  return parts.length === 3 && 
         parts[0].length === IV_LENGTH * 2 &&
         parts[1].length === AUTH_TAG_LENGTH * 2;
}

/**
 * Safely encrypt, handling already-encrypted values
 */
export function safeEncrypt(value: string | null | undefined): string | null {
  if (!value) return null;
  if (isEncrypted(value)) return value; // Already encrypted
  return encrypt(value);
}

/**
 * Safely decrypt, handling non-encrypted values
 */
export function safeDecrypt(value: string | null | undefined): string | null {
  if (!value) return null;
  if (!isEncrypted(value)) return value; // Not encrypted
  return decrypt(value);
}

// Fields that must be encrypted
export const ENCRYPTED_FIELDS = {
  organization: [
    'afipCertificate',
    'afipPrivateKey', 
    'mercadopagoAccessToken',
    'whatsappApiKey'
  ],
  employee: [
    'taxIdEncrypted', // CUIL
    'bankAccountEncrypted'
  ],
  customer: [
    'taxIdEncrypted' // CUIT
  ]
} as const;
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 6: AUDIT LOGGING (Week 2-3)            -->
  <!-- ============================================ -->
  
  <phase id="6" name="audit_logging" priority="HIGH" timeline="Week 2-3">
    <description>
      Implement tamper-proof audit logging with hash chain for compliance.
    </description>
    
    <step id="6.1" name="create_audit_schema">
      <action>Add audit log model to Prisma schema</action>
      <file>prisma/schema.prisma</file>
      <operation>append</operation>
      <content><![CDATA[

// ============================================
// AUDIT LOGGING (Ley 25.326 Compliance)
// ============================================

model AuditLog {
  id              String   @id @default(cuid())
  timestamp       DateTime @default(now())
  organizationId  String
  userId          String?
  userEmail       String?
  userRole        String?
  
  eventType       String   // e.g., auth.login.success
  eventCategory   String   // auth, data, financial, security
  
  resourceType    String?  // e.g., Job, Customer, Invoice
  resourceId      String?
  
  ipAddress       String?
  userAgent       String?
  
  previousValue   Json?    // Before state (for updates)
  newValue        Json?    // After state
  
  // Tamper-proof hash chain
  previousHash    String?
  currentHash     String
  
  @@index([organizationId, timestamp])
  @@index([eventType])
  @@index([userId])
  @@index([resourceType, resourceId])
}

model WebhookLog {
  id          String   @id @default(cuid())
  timestamp   DateTime @default(now())
  source      String   // MERCADOPAGO, WHATSAPP, etc.
  eventType   String
  payload     Json
  requestId   String?
  processed   Boolean  @default(false)
  processedAt DateTime?
  error       String?
  
  @@index([source, timestamp])
  @@index([processed])
}
]]></content>
    </step>
    
    <step id="6.2" name="create_audit_service">
      <action>Create audit logging service with hash chain</action>
      <file>lib/audit/audit-service.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import crypto from 'crypto';
import { prisma } from '@/lib/prisma';

export enum AuditEventType {
  // Authentication
  AUTH_LOGIN_SUCCESS = 'auth.login.success',
  AUTH_LOGIN_FAILURE = 'auth.login.failure',
  AUTH_LOGOUT = 'auth.logout',
  AUTH_OTP_REQUESTED = 'auth.otp.requested',
  AUTH_OTP_VERIFIED = 'auth.otp.verified',
  AUTH_OTP_FAILED = 'auth.otp.failed',
  
  // Data access
  DATA_EXPORT = 'data.export',
  DATA_BULK_READ = 'data.bulk_read',
  SENSITIVE_DATA_ACCESS = 'data.sensitive.access',
  
  // Data modification
  CUSTOMER_CREATED = 'customer.created',
  CUSTOMER_UPDATED = 'customer.updated',
  CUSTOMER_DELETED = 'customer.deleted',
  EMPLOYEE_CREATED = 'employee.created',
  EMPLOYEE_UPDATED = 'employee.updated',
  EMPLOYEE_TERMINATED = 'employee.terminated',
  JOB_CREATED = 'job.created',
  JOB_UPDATED = 'job.updated',
  JOB_DELETED = 'job.deleted',
  
  // Financial
  INVOICE_CREATED = 'invoice.created',
  INVOICE_CANCELLED = 'invoice.cancelled',
  PAYMENT_RECEIVED = 'payment.received',
  PAYMENT_REFUNDED = 'payment.refunded',
  AFIP_CERTIFICATE_UPLOADED = 'afip.certificate.uploaded',
  AFIP_CAE_REQUESTED = 'afip.cae.requested',
  
  // Security
  PERMISSION_CHANGED = 'security.permission.changed',
  ROLE_ASSIGNED = 'security.role.assigned',
  PASSWORD_CHANGED = 'security.password.changed',
  SUSPICIOUS_ACTIVITY = 'security.suspicious',
  
  // Organization
  ORG_SETTINGS_CHANGED = 'org.settings.changed',
  ORG_DATA_EXPORT_REQUESTED = 'org.data.export'
}

interface AuditEvent {
  organizationId: string;
  userId?: string;
  userEmail?: string;
  userRole?: string;
  eventType: AuditEventType | string;
  resourceType?: string;
  resourceId?: string;
  ipAddress?: string;
  userAgent?: string;
  previousValue?: any;
  newValue?: any;
}

function getEventCategory(eventType: string): string {
  if (eventType.startsWith('auth.')) return 'auth';
  if (eventType.startsWith('data.')) return 'data';
  if (eventType.startsWith('customer.') || eventType.startsWith('employee.') || eventType.startsWith('job.')) return 'data';
  if (eventType.startsWith('invoice.') || eventType.startsWith('payment.') || eventType.startsWith('afip.')) return 'financial';
  if (eventType.startsWith('security.')) return 'security';
  if (eventType.startsWith('org.')) return 'organization';
  return 'other';
}

export async function createAuditLog(event: AuditEvent): Promise<void> {
  try {
    // Get previous log for hash chain
    const previousLog = await prisma.auditLog.findFirst({
      where: { organizationId: event.organizationId },
      orderBy: { timestamp: 'desc' },
      select: { currentHash: true }
    });
    
    // Create hash of current event (tamper-proof)
    const hashContent = JSON.stringify({
      timestamp: new Date().toISOString(),
      eventType: event.eventType,
      userId: event.userId,
      resourceId: event.resourceId,
      previousHash: previousLog?.currentHash || 'GENESIS'
    });
    
    const currentHash = crypto
      .createHash('sha256')
      .update(hashContent)
      .digest('hex');
    
    await prisma.auditLog.create({
      data: {
        organizationId: event.organizationId,
        userId: event.userId,
        userEmail: event.userEmail,
        userRole: event.userRole,
        eventType: event.eventType,
        eventCategory: getEventCategory(event.eventType),
        resourceType: event.resourceType,
        resourceId: event.resourceId,
        ipAddress: event.ipAddress,
        userAgent: event.userAgent,
        previousValue: event.previousValue,
        newValue: event.newValue,
        previousHash: previousLog?.currentHash || null,
        currentHash
      }
    });
  } catch (error) {
    // Don't throw - audit logging should not break the main operation
    console.error('[Audit] Failed to create audit log:', error);
  }
}

/**
 * Verify audit log chain integrity
 */
export async function verifyAuditChain(organizationId: string): Promise<{
  valid: boolean;
  brokenAt?: string;
}> {
  const logs = await prisma.auditLog.findMany({
    where: { organizationId },
    orderBy: { timestamp: 'asc' },
    select: { id: true, previousHash: true, currentHash: true }
  });
  
  for (let i = 1; i < logs.length; i++) {
    if (logs[i].previousHash !== logs[i - 1].currentHash) {
      return { valid: false, brokenAt: logs[i].id };
    }
  }
  
  return { valid: true };
}
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 7: SECURITY HEADERS (Week 4)           -->
  <!-- ============================================ -->
  
  <phase id="7" name="security_headers" priority="MEDIUM" timeline="Week 4">
    <description>
      Configure security headers for XSS, clickjacking, and other attack prevention.
    </description>
    
    <step id="7.1" name="update_next_config">
      <action>Add security headers to Next.js config</action>
      <file>next.config.js</file>
      <operation>merge_headers</operation>
      <content><![CDATA[
const securityHeaders = [
  {
    key: 'X-DNS-Prefetch-Control',
    value: 'on'
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload'
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block'
  },
  {
    key: 'X-Frame-Options',
    value: 'SAMEORIGIN'
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'Referrer-Policy',
    value: 'origin-when-cross-origin'
  },
  {
    key: 'Content-Security-Policy',
    value: [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https: blob:",
      "font-src 'self'",
      "connect-src 'self' https://api.mercadopago.com https://graph.facebook.com wss:",
      "frame-ancestors 'none'"
    ].join('; ')
  },
  {
    key: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=(self), interest-cohort=()'
  }
];

/** @type {import('next').NextConfig} */
const nextConfig = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: securityHeaders
      }
    ];
  }
};

module.exports = nextConfig;
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 8: DATA RETENTION (Week 4-5)           -->
  <!-- ============================================ -->
  
  <phase id="8" name="data_retention" priority="MEDIUM" timeline="Week 4-5">
    <description>
      Implement data retention policies per legal requirements.
    </description>
    
    <step id="8.1" name="create_retention_config">
      <action>Create data retention configuration</action>
      <file>lib/compliance/data-retention.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
/**
 * Data Retention Policy (Ley 25.326 + ARCA Compliance)
 * 
 * | Category           | Retention | Legal Basis         | Action        |
 * |--------------------|-----------|---------------------|---------------|
 * | Invoices           | 10 years  | ARCA requirement    | Archive       |
 * | Job records        | 5 years   | Contractual         | Anonymize     |
 * | Location history   | 30 days   | Operational         | Hard delete   |
 * | Communication logs | 2 years   | Support/disputes    | Hard delete   |
 * | Audit logs         | 7 years   | Legal compliance    | Archive       |
 * | Deleted accounts   | 30 days   | Recovery period     | Hard delete   |
 * | Backup data        | 90 days   | Disaster recovery   | Rotation      |
 */

export const RETENTION_PERIODS = {
  invoices: { days: 365 * 10, action: 'archive' as const },
  jobs: { days: 365 * 5, action: 'anonymize' as const },
  locationHistory: { days: 30, action: 'delete' as const },
  communicationLogs: { days: 365 * 2, action: 'delete' as const },
  auditLogs: { days: 365 * 7, action: 'archive' as const },
  deletedAccounts: { days: 30, action: 'delete' as const },
  backups: { days: 90, action: 'rotate' as const }
};

export function getRetentionDate(category: keyof typeof RETENTION_PERIODS): Date {
  const config = RETENTION_PERIODS[category];
  const date = new Date();
  date.setDate(date.getDate() - config.days);
  return date;
}
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- PHASE 9: ARCO RIGHTS PORTAL (Week 4-6)       -->
  <!-- ============================================ -->
  
  <phase id="9" name="arco_rights" priority="MEDIUM" timeline="Week 4-6">
    <description>
      Implement ARCO rights portal for Ley 25.326 compliance.
      Users must be able to exercise Access, Rectification, Cancellation, and Opposition rights.
    </description>
    
    <step id="9.1" name="create_arco_endpoints">
      <action>Create ARCO rights API endpoints</action>
      <file>app/api/privacy/data-export/route.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/middleware/require-auth';
import { createAuditLog, AuditEventType } from '@/lib/audit/audit-service';

/**
 * ARCO Right: ACCESS (Art. 14 Ley 25.326)
 * Users can request a copy of all their personal data.
 * Must respond within 5 business days.
 */
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth(request);
    if (session instanceof NextResponse) return session;
    
    // Get all user data
    const userData = await prisma.user.findUnique({
      where: { id: session.userId },
      include: {
        organization: {
          select: { name: true, createdAt: true }
        }
      }
    });
    
    // Get jobs assigned to user (if technician)
    const jobs = await prisma.job.findMany({
      where: {
        organizationId: session.organizationId,
        assignedTechnicianId: session.userId
      },
      select: {
        id: true,
        title: true,
        scheduledDate: true,
        status: true,
        createdAt: true
      },
      take: 1000
    });
    
    // Get audit logs related to user
    const auditLogs = await prisma.auditLog.findMany({
      where: {
        organizationId: session.organizationId,
        userId: session.userId
      },
      select: {
        eventType: true,
        timestamp: true,
        resourceType: true
      },
      orderBy: { timestamp: 'desc' },
      take: 1000
    });
    
    // Log the data export request
    await createAuditLog({
      organizationId: session.organizationId,
      userId: session.userId,
      userEmail: session.email,
      eventType: AuditEventType.DATA_EXPORT,
      resourceType: 'User',
      resourceId: session.userId
    });
    
    const exportData = {
      exportDate: new Date().toISOString(),
      legalBasis: 'Ley 25.326 Art. 14 - Derecho de Acceso',
      user: {
        ...userData,
        // Exclude sensitive fields
        password: undefined
      },
      jobs,
      activityLog: auditLogs,
      retentionPolicy: {
        description: 'Sus datos se conservan según nuestra política de retención',
        details: 'https://campotech.com/privacy'
      }
    };
    
    return NextResponse.json({
      success: true,
      data: exportData
    });
    
  } catch (error) {
    console.error('[ARCO] Data export error:', error);
    return NextResponse.json(
      { success: false, error: 'Error al exportar datos' },
      { status: 500 }
    );
  }
}
]]></content>
    </step>
    
    <step id="9.2" name="create_deletion_endpoint">
      <action>Create account deletion endpoint (Cancellation right)</action>
      <file>app/api/privacy/delete-account/route.ts</file>
      <operation>create_or_replace</operation>
      <content><![CDATA[
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/middleware/require-auth';
import { createAuditLog, AuditEventType } from '@/lib/audit/audit-service';

/**
 * ARCO Right: CANCELLATION (Art. 16 Ley 25.326)
 * Users can request deletion of their personal data.
 * Must be FREE OF CHARGE (Art. 19).
 * Some data must be retained per ARCA requirements.
 */
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth(request);
    if (session instanceof NextResponse) return session;
    
    const { confirmDeletion } = await request.json();
    
    if (confirmDeletion !== true) {
      return NextResponse.json(
        { success: false, error: 'Debe confirmar la eliminación' },
        { status: 400 }
      );
    }
    
    // Check if user is the only OWNER
    if (session.role === 'OWNER') {
      const otherOwners = await prisma.user.count({
        where: {
          organizationId: session.organizationId,
          role: 'OWNER',
          id: { not: session.userId }
        }
      });
      
      if (otherOwners === 0) {
        return NextResponse.json({
          success: false,
          error: 'Debe transferir la propiedad de la organización antes de eliminar su cuenta'
        }, { status: 400 });
      }
    }
    
    // Soft delete user (mark as deleted, anonymize PII)
    await prisma.$transaction(async (tx) => {
      // Anonymize user data
      await tx.user.update({
        where: { id: session.userId },
        data: {
          status: 'DELETED',
          name: 'Usuario Eliminado',
          email: `deleted_${session.userId}@deleted.local`,
          phone: null,
          deletedAt: new Date()
        }
      });
      
      // Log the deletion request
      await createAuditLog({
        organizationId: session.organizationId,
        userId: session.userId,
        eventType: 'user.deletion_requested',
        resourceType: 'User',
        resourceId: session.userId
      });
    });
    
    return NextResponse.json({
      success: true,
      message: 'Su cuenta será eliminada permanentemente en 30 días. Datos fiscales se conservarán según requisitos legales (ARCA).'
    });
    
  } catch (error) {
    console.error('[ARCO] Delete account error:', error);
    return NextResponse.json(
      { success: false, error: 'Error al procesar solicitud' },
      { status: 500 }
    );
  }
}
]]></content>
    </step>
  </phase>

  <!-- ============================================ -->
  <!-- VERIFICATION PHASE                           -->
  <!-- ============================================ -->
  
  <phase id="verify" name="verification" priority="CRITICAL">
    <description>
      Verify all security implementations are working correctly.
    </description>
    
    <test_suite name="authentication">
      <test id="AUTH-001" priority="CRITICAL">
        <name>Valid OTP within 5 minutes</name>
        <expected>Login successful</expected>
      </test>
      <test id="AUTH-002" priority="CRITICAL">
        <name>Expired OTP (greater than 5 minutes)</name>
        <expected>Login rejected</expected>
      </test>
      <test id="AUTH-003" priority="CRITICAL">
        <name>6th login attempt in 15 min</name>
        <expected>Account locked, 429 response</expected>
      </test>
      <test id="AUTH-004" priority="CRITICAL">
        <name>Session token after logout</name>
        <expected>Request rejected (401)</expected>
      </test>
    </test_suite>
    
    <test_suite name="authorization">
      <test id="AUTHZ-001" priority="CRITICAL">
        <name>TECHNICIAN accessing ADMIN route</name>
        <expected>403 Forbidden</expected>
      </test>
      <test id="AUTHZ-002" priority="CRITICAL">
        <name>User accessing other org data</name>
        <expected>404 Not Found (not 403, to prevent enumeration)</expected>
      </test>
      <test id="AUTHZ-003" priority="CRITICAL">
        <name>Suspended org accessing API</name>
        <expected>403 Forbidden</expected>
      </test>
    </test_suite>
    
    <test_suite name="data_isolation">
      <test id="ISO-001" priority="CRITICAL">
        <name>Query without org filter</name>
        <expected>Query rejected or auto-filtered</expected>
      </test>
      <test id="ISO-002" priority="CRITICAL">
        <name>Direct ID access from other org</name>
        <expected>404 Not Found</expected>
      </test>
    </test_suite>
    
    <test_suite name="input_validation">
      <test id="VAL-001" priority="CRITICAL">
        <name>SQL injection in search</name>
        <expected>Query escaped/parameterized, no error</expected>
      </test>
      <test id="VAL-002" priority="CRITICAL">
        <name>XSS in job description</name>
        <expected>HTML escaped</expected>
      </test>
      <test id="VAL-003" priority="HIGH">
        <name>Invalid CUIT format</name>
        <expected>Validation error</expected>
      </test>
    </test_suite>
    
    <test_suite name="webhooks">
      <test id="WH-001" priority="CRITICAL">
        <name>Valid MercadoPago signature</name>
        <expected>Webhook processed</expected>
      </test>
      <test id="WH-002" priority="CRITICAL">
        <name>Invalid signature</name>
        <expected>401 Unauthorized</expected>
      </test>
      <test id="WH-003" priority="HIGH">
        <name>Missing signature header</name>
        <expected>401 Unauthorized</expected>
      </test>
    </test_suite>
    
    <verification_commands>
      <command name="check_org_isolation">
        grep -rn "prisma\.\w*\.findMany\|findFirst\|findUnique" --include="*.ts" | grep -v "organizationId" | grep -v node_modules | wc -l
        <!-- Expected: 0 -->
      </command>
      <command name="check_auth_middleware">
        grep -rn "requireAuth" --include="route.ts" | wc -l
        <!-- Should match number of API routes -->
      </command>
      <command name="check_zod_validation">
        grep -rn "safeParse\|parse(" --include="route.ts" | wc -l
        <!-- Should be greater than 0 for each POST/PATCH route -->
      </command>
      <command name="check_security_headers">
        curl -I https://your-domain.com | grep -i "strict\|x-frame\|x-content"
        <!-- Should show security headers -->
      </command>
    </verification_commands>
  </phase>

  <!-- ============================================ -->
  <!-- COMPLETION CHECKLIST                         -->
  <!-- ============================================ -->
  
  <completion_checklist>
    <category name="Legal Foundation">
      <item>Privacy Policy published (Spanish)</item>
      <item>Terms of Service published (Spanish)</item>
      <item>DPO/contact designated</item>
      <item>RNBD registration completed with AAIP</item>
    </category>
    
    <category name="Data Protection">
      <item>Consent mechanisms implemented (not pre-checked)</item>
      <item>ARCO request handling process (5 business days)</item>
      <item>Data retention policy enforced</item>
      <item>Field-level encryption for sensitive data</item>
    </category>
    
    <category name="Technical Security">
      <item>Authentication middleware on ALL API routes</item>
      <item>Organization isolation on ALL database queries</item>
      <item>Rate limiting configured</item>
      <item>Webhook signature verification</item>
      <item>Input validation with Zod</item>
      <item>Audit logging with hash chain</item>
      <item>Security headers configured</item>
    </category>
    
    <category name="ARCA Integration">
      <item>Certificate storage encrypted</item>
      <item>Invoice templates include IVA discrimination</item>
      <item>Fiscal transparency legend included</item>
      <item>10-year invoice storage configured</item>
    </category>
    
    <category name="Incident Response">
      <item>Response plan documented</item>
      <item>Team roles assigned</item>
      <item>AAIP notification template ready</item>
    </category>
  </completion_checklist>

  <!-- ============================================ -->
  <!-- AGENT INSTRUCTIONS                           -->
  <!-- ============================================ -->
  
  <agent_instructions>
    <instruction priority="CRITICAL">Execute Phase 0 (Reconnaissance) first to understand codebase structure</instruction>
    <instruction priority="CRITICAL">Organization isolation is the #1 priority - fix ALL unprotected queries</instruction>
    <instruction priority="CRITICAL">NEVER skip webhook signature verification</instruction>
    <instruction priority="CRITICAL">Every API route MUST use requireAuth middleware</instruction>
    <instruction priority="HIGH">All user input MUST be validated with Zod before processing</instruction>
    <instruction priority="HIGH">Audit logging should not block main operations (async, catch errors)</instruction>
    <instruction priority="HIGH">Use Spanish for all user-facing error messages</instruction>
    <instruction priority="MEDIUM">Test each security feature after implementation</instruction>
    <instruction priority="MEDIUM">Run verification commands after each phase</instruction>
    
    <security_reminders>
      <reminder>Ley 25.326: ARCO rights must be responded to within 5 business days</reminder>
      <reminder>Ley 25.326: ARCO rights must be FREE (Art. 19)</reminder>
      <reminder>AAIP: Maximum fine exposure is ARS 50,000,000 per proceeding</reminder>
      <reminder>ARCA: Invoices must be stored for 10 years</reminder>
      <reminder>ARCA: Include fiscal transparency legend on all invoices</reminder>
      <reminder>Audit logs: 7-year retention with tamper-proof hash chain</reminder>
    </security_reminders>
  </agent_instructions>

</security_implementation_task>
